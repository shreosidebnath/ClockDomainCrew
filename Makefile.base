MAKEFLAGS += --silent
    
SBT = sbt
SHELL := /bin/bash
GEN_DIR := "${CORE_DIR}/generated"
ERROR_REP := "error.rpt"
TC_DIR := "${GEN_DIR}/synTestCases"

# Run everything and scan for errors
.PHONY: list
list:
	@grep '^[^#[:space:]].*:' Makefile.base

.PHONY: all
all: clean lint publish cov yosys docs ipf check

.PHONY: check
check: 
	@echo 
	@echo Checking for errors
	rm -rf ${ERROR_REP}
# lint (scalafix) and format (scalafmt) checks
	grep -Hn -E "\[error] scalafmt" lint.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "\[error] ---" lint.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "Error|error" lint.rpt | tee -a ${ERROR_REP}
# docs
	grep -Hn -E "Error|error" docs/doc.rpt | tee -a ${ERROR_REP}
	grep -Hn -E "Error|error" ${CORE_DIR}/docs/doc.rpt | tee -a ${ERROR_REP} 
# publish
	grep -Hn -E "Error|error|Warn|warn" ./docs/publish.rpt | tee -a ${ERROR_REP} 
# test and verilog reports
	grep -Hn -E "Error|error" ${GEN_DIR}/verilog.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "Error|error" ${GEN_DIR}/test.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "fail" ${GEN_DIR}/test.rpt | grep -v "failed 0" | tee -a ${ERROR_REP} 
# summary reports
	grep -Hn -E "Error|error" ${TC_DIR}/area_summary.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "Error|error" ${TC_DIR}/timing_summary.rpt | tee -a ${ERROR_REP} 
# synTestCases
	grep -Hn -E "Error|error" ${TC_DIR}/*/timing.rpt | tee -a ${ERROR_REP} 
	grep -Hn -E "Error|error" ${TC_DIR}/*/yosys.log | tee -a ${ERROR_REP} 
# check that IP Factory objects were correctly generated
	@if [ ! -f .ipf/${CORE_NAME}.json ]; then \
		printf "Error - Missing JSON file\n" | tee -a ${ERROR_REP}; \
	fi
	@if [ ! -f .ipf/${CORE_NAME}.pdf ]; then \
		printf "Error - Missing User Guide\n" | tee -a ${ERROR_REP}; \
	fi
	@if [ ! -f .ipf/${CORE_NAME}.sdc  ]; then \
		printf "Error - Missing SDC file\n" | tee -a ${ERROR_REP}; \
	fi
# existence of this file is an implicit check there are also Verilog files
	@if [ ! -f ".ipf/filelist.f" ]; then \
		printf "Error - Missing Verilog file list\n" | tee ${ERROR_REP}; \
	fi
# check for errors
	@if [ ! -s ${ERROR_REP} ]; then \
	  printf "\033[1;32mALL TESTS PASSED WITH NO ERRORS\033[0m\n" ;\
	else \
	  printf "\033[1;31mTESTS COMPLETED WITH ERRORS\033[0m\n" ;\
	fi

# Start with a fresh directory
.PHONY: clean
clean: 
	@echo Cleaning
	rm -rf docs/*.rpt
	rm -rf ipf.rpt
	rm -rf lint.rpt
	rm -rf error.rpt
	rm -rf target
	rm -rf project/target
	rm -rf project/project 
	rm -rf ${CORE_DIR}/docs/*.rpt
	rm -rf ${CORE_DIR}/generated 
	rm -rf ${CORE_DIR}/target 
	rm -rf ${CORE_DIR}/project/project 
	rm -rf ${CORE_DIR}/project/target

# Run the tests with Scala code coverage enables
.PHONY: cov
cov:
	@echo Running tests with coverage enabled
	mkdir -p ${CORE_DIR}/generated
	$(SBT) clean \
	coverageOn \
	"project ${SBT_PROJECT}" \
	test \
	${RUN_CMD} \
	coverageReport | tee ${CORE_DIR}/generated/test.rpt
	rm -rf *.anno.json
	firefox --new-window ${CORE_DIR}/generated/scalaCoverage/scoverage-report/index.html 2>/dev/null &

# Generate the documentation
.PHONY: docs
docs:
	@echo Building API docs
	$(SBT) "project ${SBT_PROJECT}" doc | tee docs/doc.rpt
	firefox --new-window ${CORE_DIR}/target/scala-2.13/api/${API_PATH}/index.html 2>/dev/null &

	@echo Building User Guide
	cd ${CORE_DIR}/docs/user-guide && pdflatex ${CORE}.tex 
# Rerun to generate TOC
	cd ${CORE_DIR}/docs/user-guide && pdflatex ${CORE}.tex | tee -a ../doc.rpt 
# Clean up temp files
	cd ${CORE_DIR}/docs/user-guide && rm *.aux *.toc *.out *.log 
	firefox ${CORE_DIR}/docs/user-guide/${CORE}.pdf 2>/dev/null & 

.PHONY: ipf 
ipf:
# Generate IP Factory deliverables
	@echo Building artifacts for the IP Factory to download
	$(SBT) "project ${SBT_PROJECT}" ${RUN_CMD} | tee -a ipf.rpt 
# Copy the User Guide to the .ipf/ directory for upload
	cp -f ${CORE_DIR}/docs/user-guide/${CORE}.pdf .ipf/${CORE}.pdf
	rm -rf *.anno.json

# Run the scalafix and scalafmt linters
.PHONY: lint
lint: 
	rm -rf lint.rpt
	@echo Running scalafmt checks
	$(SBT) "scalafmtCheck" | tee -a lint.rpt
	@echo Running scalafix lint checks
	$(SBT) "Compile/scalafixAll --check" "Test/scalafixAll --check" | tee -a lint.rpt

# Publish locally
.PHONY: publish
publish: 
	@echo Publishing libraries locally
	$(SBT) "project ${SBT_PROJECT}" publishLocal | tee docs/publish.rpt

# Run the tests
.PHONY: test
test:
	@echo Running tests
	mkdir -p ${CORE_DIR}/generated
	$(SBT) "project ${SBT_PROJECT}" test | tee ${CORE_DIR}/generated/test.rpt
	rm -rf *anno.json

# Generate Verilog and synthesize
.PHONY: verilog
verilog:
	@echo Generate Verilog for synthesis
	mkdir -p ${CORE_DIR}/generated
	$(SBT) "project ${SBT_PROJECT}" run | tee ${CORE_DIR}/generated/verilog.rpt
	rm -rf *anno.json

# Run synthesis on generated Verilog; generate timing and area reports
.PHONY: yosys
yosys: 
	make verilog
	cd ${CORE_DIR}/generated/synTestCases && source run.sh
	echo "---------------------------------------------------------"
	echo "                      SUMMARY                            "
	echo "---------------------------------------------------------"
	cat ${CORE_DIR}/generated/synTestCases/{area,timing}_summary.rpt